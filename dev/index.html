<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · uCSV.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>uCSV.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Functions-1">Functions</a></li><li><a class="toctext" href="#Manual-1">Manual</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="man/defaults.html">Getting Started</a></li><li><a class="toctext" href="man/headers.html">Headers</a></li><li><a class="toctext" href="man/dataframes.html">Reading into DataFrames</a></li><li><a class="toctext" href="man/delimiters.html">Delimiters</a></li><li><a class="toctext" href="man/missingdata.html">Missing Data</a></li><li><a class="toctext" href="man/declaring-column-element-types.html">Declaring Column Element Types</a></li><li><a class="toctext" href="man/declaring-column-vector-types.html">Declaring Column Vector Types</a></li><li><a class="toctext" href="man/international.html">International Representations for Numbers</a></li><li><a class="toctext" href="man/customparsers.html">Custom Parsers</a></li><li><a class="toctext" href="man/quotes-escapes.html">Quotes and Escapes</a></li><li><a class="toctext" href="man/comments-skiplines.html">Skipping Comments and Rows</a></li><li><a class="toctext" href="man/malformed.html">Malformed Data</a></li><li><a class="toctext" href="man/url.html">Reading Data from URLs</a></li><li><a class="toctext" href="man/compressed.html">Reading Compressed Datasets</a></li><li><a class="toctext" href="man/unsupported.html">Common Formatting Issues</a></li><li><a class="toctext" href="man/write.html">Writing Data</a></li><li><a class="toctext" href="man/benchmarks.html">Benchmarks</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/cjprybol/uCSV.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="uCSV.jl-Documentation-1" href="#uCSV.jl-Documentation-1">uCSV.jl Documentation</a></h1><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="uCSV.read" href="#uCSV.read"><code>uCSV.read</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">read(input;
     delim=&#39;,&#39;,
     quotes=missing,
     escape=missing,
     comment=missing,
     encodings=Dict{String, Any}(),
     header=0,
     skiprows=Vector{Int}(),
     types=Dict{Int,DataType}(),
     allowmissing=Dict{Int,Bool}(),
     coltypes=Vector,
     colparsers=Dict{Int,Function}(),
     typeparsers=Dict{DataType, Function}(),
     typedetectrows=1,
     skipmalformed=false,
     trimwhitespace=false)</code></pre><p>Take an input file or IO source and user-defined parsing rules and return:</p><ol><li>a <code>Vector{Any}</code> containing the parsed columns</li><li>a <code>Vector{String}</code> containing the header (column names)</li></ol><p><strong>Arguments</strong></p><ul><li><code>input</code><ul><li>the path to a local file, or an open IO source from which to read data</li></ul></li><li><code>delim</code><ul><li>a <code>Char</code> or <code>String</code> that separates fields in the dataset</li><li>default: <code>delim=&#39;,&#39;</code><ul><li>for CSV files</li></ul></li><li>frequently used:<ul><li><code>delim=&#39;\t&#39;</code></li><li><code>delim=&#39; &#39;</code></li><li><code>delim=&#39;|&#39;</code></li></ul></li></ul></li><li><code>quotes</code><ul><li>a <code>Char</code> used for quoting fields in the dataset</li><li>default: <code>quotes=missing</code><ul><li>by default, the parser does not check for quotes</li></ul></li><li>frequently used:<ul><li><code>quotes=&#39;&quot;&#39;</code></li></ul></li></ul></li><li><code>escape</code><ul><li>a <code>Char</code> used for escaping other reserved parsing characters</li><li>default: <code>escape=missing</code><ul><li>by default, the parser does not check for escapes</li></ul></li><li>frequently used:<ul><li><code>escape=&#39;&quot;&#39;</code><ul><li>double-quotes within quotes, e.g. <code>&quot;firstname &quot;&quot;nickname&quot;&quot; lastname&quot;</code></li></ul></li><li><code>escape=&#39;\\&#39;</code><ul><li>note that the first backslash is just to escape the second backslash</li><li>e.g. <code>&quot;firstname \&quot;nickname\&quot; lastname&quot;</code></li></ul></li></ul></li></ul></li><li><code>comment</code><ul><li>a <code>Char</code> or <code>String</code> at the beginning of lines that should be skipped as comments<ul><li>note that skipped comment lines do not contribute to the line count for the header (if the user requests parsing a header on a specific row) or for skiprows</li></ul></li><li>default: <code>comment=missing</code><ul><li>by default, the parser does not check for comments</li></ul></li><li>frequently used:<ul><li><code>comment=&#39;#&#39;</code></li><li><code>comment=&#39;!&#39;</code></li><li><code>comment=&quot;#!&quot;</code></li></ul></li></ul></li><li><code>encodings</code><ul><li>a <code>Dict{String, Any}</code> mapping parsed fields to Julia values<ul><li>if your dataset has booleans that are not represented as <code>&quot;true&quot;</code> and <code>&quot;false&quot;</code> or missing values that you&#39;d like to read as <code>missing</code>s, you&#39;ll need to use this!</li></ul></li><li>default: <code>encodings=Dict{String, Any}()</code><ul><li>by default, the parser does not check for any reserved fields</li></ul></li><li>frequently used:<ul><li><code>encodings=Dict(&quot;&quot; =&gt; missing)</code></li><li><code>encodings=Dict(&quot;NA&quot; =&gt; missing)</code></li><li><code>encodings=Dict(&quot;N/A&quot; =&gt; missing)</code></li><li><code>encodings=Dict(&quot;NULL&quot; =&gt; missing)</code></li><li><code>encodings=Dict(&quot;TRUE&quot; =&gt; true, &quot;FALSE&quot; =&gt; false)</code></li><li><code>encodings=Dict(&quot;True&quot; =&gt; true, &quot;False&quot; =&gt; false)</code></li><li><code>encodings=Dict(&quot;T&quot; =&gt; true, &quot;F&quot; =&gt; false)</code></li><li><code>encodings=Dict(&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false)</code></li><li>... your encodings here ...<ul><li>can include any number of <code>String</code> =&gt; value mappings</li><li>note that if the user requests <code>quotes</code>, <code>escapes</code>, or <code>trimwhitespace</code>, these requests will be applied (removed) the raw string <em>BEFORE</em> checking whether the field matches any strings in in the <code>encodings</code> argument</li></ul></li></ul></li></ul></li><li><code>header</code><ul><li>an <code>Int</code> indicating which line of the dataset contains column names or a <code>Vector{String}</code> of column names<ul><li>note that commented lines and blank lines do not contribute to this value e.g. if the first 3 lines of your dataset are comments, you&#39;ll still need to set <code>header=1</code> to interpret the first line of parsed data as the header</li></ul></li><li>default: <code>header=0</code><ul><li>no header is checked for by default</li></ul></li><li>frequently used:<ul><li><code>header=1</code></li></ul></li></ul></li><li><code>skiprows</code><ul><li>a <code>Range</code> or <code>Vector</code> of <code>Int</code>s indicating which rows to skip in the dataset<ul><li>note that this is 1-based in reference to the first row <em>AFTER</em> the header. if <code>header=0</code> or is provided by the user, this will be the first non-empty line in the dataset. otherwise <code>skiprows=1:1</code> will skip the <code>header+1</code>-nth line in the file</li></ul></li><li>default: <code>skiprows=Vector{Int}()</code><ul><li>no rows are skipped</li></ul></li></ul></li><li><code>types</code><ul><li>declare the types of the columns<ul><li>scalar, e.g. <code>types=Bool</code><ul><li>scalars will be broadcast to apply to every column of the dataset</li></ul></li><li>vector, e.g. <code>types=[Bool, Int, Float64, String, Symbol, Date, DateTime]</code><ul><li>the vector length must match the number of parsed columns</li></ul></li><li>dictionary, e.g. <code>types=(&quot;column1&quot; =&gt; Bool)</code> or <code>types=(1 =&gt; Union{Int, Missing})</code><ul><li>users can refer to the columns by name (only if a header is provided or parsed!) or by index</li></ul></li></ul></li><li>default:<ul><li><code>types=Dict{Int,DataType}()</code><ul><li>column-types will be interpreted from the dataset</li></ul></li></ul></li><li>built-in support for parsing the following:<ul><li><code>Int</code></li><li><code>Float64</code></li><li><code>String</code></li><li><code>Symbol</code></li><li><code>Date</code> – only the default date format will work</li><li><code>DateTime</code> – only the default datetime format will work</li><li>for other types or unsupported formats, see <code>colparsers</code> and <code>typeparsers</code></li></ul></li></ul></li><li><code>allowmissing</code><ul><li>declare whether columns should have element-type <code>Union{T, Missing} where T</code><ul><li>boolean scalar, e.g. <code>allowmissing=true</code><ul><li>scalars will be broadcast to apply to every column of the dataset</li></ul></li><li>vector, e.g. <code>allowmissing=[true, false, true, true]</code><ul><li>the vector length must match the number of parsed columns</li></ul></li><li>dictionary, e.g. <code>allowmissing=(&quot;column1&quot; =&gt; true)</code> or <code>allowmissing=(17 =&gt; true)</code><ul><li>users can refer to the columns by name (only if a header is provided or parsed!) or by index</li></ul></li></ul></li><li>default: <code>allowmissing=Dict{Int,Bool}()</code><ul><li>Allowing missing values is determined by type detection in rows <code>1:typedetectrows</code></li></ul></li></ul></li><li><code>coltypes</code><ul><li>declare the type of vector that should be used for columns</li><li>should work for any AbstractVector that allows <code>push!</code>ing values<ul><li>scalar, e.g. <code>coltypes=CategoricalVector</code><ul><li>scalars will be broadcast to apply to every column of the dataset</li></ul></li><li>vector, e.g. <code>coltypes=[CategoricalVector, Vector, CategoricalVector]</code><ul><li>the vector length must match the number of parsed columns</li></ul></li><li>dictionary, e.g. <code>coltypes=(&quot;column1&quot; =&gt; CategoricalVector)</code> or <code>coltypes=(17 =&gt; CategoricalVector)</code><ul><li>users can refer to the columns by name (only if a header is provided or parsed!) or by index</li></ul></li></ul></li><li>default: <code>coltypes=Vector</code><ul><li>all columns are returned as standard julia <code>Vector</code>s</li></ul></li></ul></li><li><code>colparsers</code><ul><li>provide custom functions for converting parsed strings to values by column<ul><li>scalar, e.g. <code>colparsers=(x -&gt; parse(Float64, replace(x, &#39;,&#39;, &#39;.&#39;)))</code><ul><li>scalars will be broadcast to apply to every column of the dataset</li></ul></li><li>vector, e.g. <code>colparsers=[x -&gt; mydateparser(x), x -&gt; mytimeparser(x)]</code><ul><li>the vector length must match the number of parsed columns</li></ul></li><li>dictionary, e.g. <code>colparsers=(&quot;column1&quot; =&gt; x -&gt; mydateparser(x))</code><ul><li>users can refer to the columns by name (only if a header is provided or parsed!) or by index</li></ul></li></ul></li><li>default: <code>colparsers=Dict{Int,Function}()</code><ul><li>column parsers are determined based on user-specified types and those detected from the data</li></ul></li></ul></li><li><code>typeparsers</code><ul><li>provide custom functions for converting parsed strings to values by column type<ul><li><em>NOTE</em> must be used with <code>coltypes</code>. If you supply a custom Int parser you&#39;d like to use to parse column 6, you&#39;ll need to set <code>coltypes=dict(6 =&gt; Int)</code> for it to work</li></ul></li><li>default: <code>colparsers=Dict{DataType, Function}()</code><ul><li>column parsers are determined based on user-specified types and those detected from the data</li></ul></li><li>frequently used:<ul><li><code>typeparsers=Dict(Float64 =&gt; x -&gt; parse(Float64, replace(x, &#39;,&#39; =&gt; &#39;.&#39;)))</code> # decimal-comma floats!</li></ul></li></ul></li><li><code>typedetectrows</code><ul><li>specify how many rows of data to read before interpretting the values that each column should take on</li><li>default: <code>typedetectrows=1</code><ul><li>must be &gt;= 1</li><li>commented, skipped, and empty lines are not counted when determining which rows are used for type detection, e.g. setting <code>typedetectrows=10</code> and <code>skiprows=1:5</code> means type detection will occur on rows <code>6:15</code></li></ul></li></ul></li><li><code>skipmalformed</code><ul><li>specify whether the parser should skip a line or fail with an error if a line is parsed but does not contain the expected number of rows</li><li>default: <code>skipmalformed=false</code><ul><li>malformed lines result in an error</li></ul></li></ul></li><li><code>trimwhitespace</code><ul><li>specify whether should extra whitespace be removed from the beginning and ends of fields.<ul><li>e.g <code>...., myfield ,...</code><ul><li><code>trimwhitespace=false</code> -&gt; <code>&quot; myfield &quot;</code></li><li><code>trimwhitespace=true</code>  -&gt; <code>&quot;myfield&quot;</code></li></ul></li></ul></li><li>leading and trailing whitespace <em>OUTSIDE</em> of quoted fields is trimmed by default.<ul><li>e.g. <code>...., &quot; myfield &quot; ,...</code> -&gt; <code>&quot; myfield &quot;</code> when <code>quotes=&#39;&quot;&#39;</code></li></ul></li><li><code>trimwhitespace=true</code> will also trim leading and trailing whitespace <em>WITHIN</em> quotes</li><li>default: <code>trimwhitespace=false</code></li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/cjprybol/uCSV.jl/blob/dbf6ce3e41bcc60842b9f1edf5b5bcf207e0dab1/src/read.jl#L1-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="uCSV.write" href="#uCSV.write"><code>uCSV.write</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">function write(output;
               header=missing,
               data=missing,
               delim=&#39;,&#39;,
               quotes=missing,
               quotetypes=AbstractString)</code></pre><p>Write a dataset to disk or IO</p><p><strong>Arguments</strong></p><ul><li><code>output</code><ul><li>the path on disk or IO where you want to write to</li></ul></li><li><code>header</code><ul><li>the column names for the data to <code>output</code></li><li>default: <code>header=missing</code><ul><li>no header is written</li></ul></li></ul></li><li><code>data</code><ul><li>the dataset to write to <code>output</code></li><li>default: <code>data=missing</code><ul><li>no data is written</li></ul></li></ul></li><li><code>delim</code><ul><li>the delimiter to seperate fields by</li><li>default: <code>delim=&#39;,&#39;</code><ul><li>for CSV files</li></ul></li><li>frequently used:<ul><li><code>delim=&#39;\t&#39;</code></li><li><code>delim=&#39; &#39;</code></li><li><code>delim=&#39;|&#39;</code></li></ul></li></ul></li><li><code>quotes</code><ul><li>the quoting character to use when writing fields</li><li>default: <code>quotes=missing</code><ul><li>fields are not quoted by default, and fields are written using julia&#39;s default string-printing mechanisms</li></ul></li></ul></li><li><code>quotetypes::Type</code><ul><li>when quoting fields, quote only columns where <code>coltype &lt;: quotetypes</code><ul><li>columns of type <code>Union{&lt;:quotetypes, Missing}</code> will also be quoted</li></ul></li><li>default: <code>quotetypes=AbsractString</code><ul><li>only the header and fields where <code>coltype &lt;: AbsractString</code> will be quoted</li></ul></li><li>frequently used:<ul><li><code>quotetypes=Any</code><ul><li>quote every field in the dataset</li></ul></li></ul></li></ul></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/cjprybol/uCSV.jl/blob/dbf6ce3e41bcc60842b9f1edf5b5bcf207e0dab1/src/write.jl#L1-L43">source</a><div><div><pre><code class="language-none">function write(output,
               df;
               delim=&#39;,&#39;,
               quotes=missing,
               quotetypes=AbstractString)</code></pre><p>Write a DataFrame to disk or IO</p></div></div><a class="source-link" target="_blank" href="https://github.com/cjprybol/uCSV.jl/blob/dbf6ce3e41bcc60842b9f1edf5b5bcf207e0dab1/src/write.jl#L93-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="uCSV.tomatrix" href="#uCSV.tomatrix"><code>uCSV.tomatrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert the data output by uCSV.read to a <code>Matrix</code>. Column names are ignored</p></div></div><a class="source-link" target="_blank" href="https://github.com/cjprybol/uCSV.jl/blob/dbf6ce3e41bcc60842b9f1edf5b5bcf207e0dab1/src/helperfunctions.jl#L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="uCSV.tovector" href="#uCSV.tovector"><code>uCSV.tovector</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Convert the data output by uCSV.read to a <code>Vector</code>. Column names are ignored</p></div></div><a class="source-link" target="_blank" href="https://github.com/cjprybol/uCSV.jl/blob/dbf6ce3e41bcc60842b9f1edf5b5bcf207e0dab1/src/helperfunctions.jl#L105">source</a></section><h2><a class="nav-anchor" id="Manual-1" href="#Manual-1">Manual</a></h2><ul><li><a href="man/defaults.html#Getting-Started-1">Getting Started</a></li><li><a href="man/headers.html#Headers-1">Headers</a></li><li><a href="man/dataframes.html#Reading-into-DataFrames-1">Reading into DataFrames</a></li><li><a href="man/delimiters.html#Delimiters-1">Delimiters</a></li><li><a href="man/missingdata.html#Missing-Data-1">Missing Data</a></li><li><a href="man/declaring-column-element-types.html#Declaring-Column-Element-Types-1">Declaring Column Element Types</a></li><li><a href="man/declaring-column-vector-types.html#Declaring-Column-Vector-Types-1">Declaring Column Vector Types</a></li><li><a href="man/international.html#International-Representations-for-Numbers-1">International Representations for Numbers</a></li><li><a href="man/customparsers.html#Custom-Parsers-1">Custom Parsers</a></li><li><a href="man/quotes-escapes.html#Quotes-and-Escapes-1">Quotes and Escapes</a></li><li><a href="man/comments-skiplines.html#Skipping-Comments-and-Rows-1">Skipping Comments and Rows</a></li><li><a href="man/malformed.html#Malformed-Data-1">Malformed Data</a></li><li><a href="man/url.html#Reading-Data-from-URLs-1">Reading Data from URLs</a></li><li><a href="man/compressed.html#Reading-Compressed-Datasets-1">Reading Compressed Datasets</a></li><li><a href="man/unsupported.html#Common-Formatting-Issues-1">Common Formatting Issues</a></li><li><a href="man/write.html#Writing-Data-1">Writing Data</a></li><li><a href="man/benchmarks.html#Benchmarks-1">Benchmarks</a></li></ul><footer><hr/><a class="next" href="man/defaults.html"><span class="direction">Next</span><span class="title">Getting Started</span></a></footer></article></body></html>
